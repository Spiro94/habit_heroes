import 'dart:async';

import 'package:bloc_concurrency/bloc_concurrency.dart';
import 'package:collection/collection.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../outside/repositories/kids/repository.dart';
import '../../../outside/repositories/task_instances/repository.dart';
import '../../../outside/repositories/task_schedules/repository.dart';
import '../../../outside/repositories/task_templates/repository.dart';
import '../../../shared/models/enums/part_of_day.dart';
import '../../../shared/models/task_schedule.dart';
import '../../../shared/models/task_template.dart';
import '../base.dart';
import 'events.dart';
import 'state.dart';

class ParentTasks_Bloc extends Bloc_Base<ParentTasks_Event, ParentTasks_State> {
  ParentTasks_Bloc({
    required String userId,
    required Kids_Repository kidRepository,
    required TaskInstance_Repository taskInstanceRepository,
    required TaskTemplate_Repository taskTemplateRepository,
    required TaskSchedule_Repository taskScheduleRepository,
    required ParentTasks_State initialState,
  }) : _userId = userId,
       _kidRepository = kidRepository,
       _taskInstanceRepository = taskInstanceRepository,
       _taskTemplateRepository = taskTemplateRepository,
       _taskScheduleRepository = taskScheduleRepository,
       super(initialState) {
    on<ParentTasks_Event_LoadTasks>(_onLoadTasks, transformer: sequential());
    on<ParentTasks_Event_AddTask>(_onAddTask, transformer: sequential());
    on<ParentTasks_Event_UpdateTask>(_onUpdateTask, transformer: sequential());
    on<ParentTasks_Event_DeleteTask>(_onDeleteTask, transformer: sequential());
    on<ParentTasks_Event_LoadTaskForEditing>(
      _onLoadTaskForEditing,
      transformer: sequential(),
    );
  }

  final String _userId;
  final Kids_Repository _kidRepository;
  final TaskInstance_Repository _taskInstanceRepository;
  final TaskTemplate_Repository _taskTemplateRepository;
  final TaskSchedule_Repository _taskScheduleRepository;

  Future<void> _onLoadTasks(
    ParentTasks_Event_LoadTasks event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(loadStatus: LoadStatus.loading));
    try {
      // Load today's task instances
      final taskInstances = await _taskInstanceRepository
          .getTodayTaskInstances();
      // Load all templates and schedules for listing
      final templates = await _taskTemplateRepository.getTaskTemplates();
      final schedules = await _taskScheduleRepository.getTaskSchedules();
      // RLS policies automatically filter kids by authenticated parent
      final kids = await _kidRepository.getKidsForParent();
      emit(
        state.copyWith(
          loadStatus: LoadStatus.loaded,
          taskInstances: taskInstances,
          kids: kids,
          taskTemplates: templates,
          taskSchedules: schedules,
        ),
      );
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          loadStatus: LoadStatus.error,
          setLoadErrorMessage: e.toString,
        ),
      );
    }
  }

  Future<void> _onAddTask(
    ParentTasks_Event_AddTask event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(createTaskStatus: CreateTaskStatus.creating));
    try {
      // Step 1: Create the task template
      final taskTemplate = TaskTemplate(
        id: '', // Will be generated by Supabase
        parentId: _userId,
        title: event.title,
        description: event.description,
        points: event.points,
      );

      final createdTemplate = await _taskTemplateRepository.createTaskTemplate(
        template: taskTemplate,
      );

      // Step 2: Create MULTIPLE task schedules for the same template
      for (final scheduleInput in event.schedules) {
        final taskSchedule = TaskSchedule(
          id: '', // Will be generated by Supabase
          taskTemplateId: createdTemplate.id,
          kidId: scheduleInput.kidId,
          daysOfWeek: scheduleInput.daysOfWeek,
          timeOfDay: scheduleInput.timeOfDay != null
              ? _parseTimeOfDay(scheduleInput.timeOfDay!)
              : null,
          specificDate: scheduleInput.specificDate,
        );

        await _taskScheduleRepository.createTaskSchedule(
          schedule: taskSchedule,
        );
      }

      // Step 3: Mark creation as successful
      emit(state.copyWith(createTaskStatus: CreateTaskStatus.success));

      // Step 4: Reload tasks to show the new task instances
      add(const ParentTasks_Event_LoadTasks());
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          createTaskStatus: CreateTaskStatus.error,
          setCreateTaskErrorMessage: e.toString,
        ),
      );
    }
  }

  PartOfDay? _parseTimeOfDay(String timeOfDay) {
    return PartOfDay.values.firstWhereOrNull((e) => e.key == timeOfDay);
  }

  Future<void> _onUpdateTask(
    ParentTasks_Event_UpdateTask event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(updateTaskStatus: UpdateTaskStatus.updating));
    try {
      // Update the task template with new values
      final updatedTemplate = TaskTemplate(
        id: event.templateId,
        parentId: _userId,
        title: event.title,
        description: event.description,
        points: event.points,
      );

      await _taskTemplateRepository.updateTaskTemplate(
        template: updatedTemplate,
      );

      // Replace existing schedules for this template.
      final allSchedules = await _taskScheduleRepository.getTaskSchedules();
      final existingForTemplate = allSchedules
          .where((s) => s.taskTemplateId == event.templateId)
          .toList();

      for (final s in existingForTemplate) {
        await _taskScheduleRepository.deleteTaskSchedule(id: s.id);
      }

      for (final input in event.schedules) {
        final taskSchedule = TaskSchedule(
          id: '',
          taskTemplateId: event.templateId,
          kidId: input.kidId,
          daysOfWeek: input.daysOfWeek,
          timeOfDay: input.timeOfDay != null
              ? _parseTimeOfDay(input.timeOfDay!)
              : null,
          specificDate: input.specificDate,
        );

        await _taskScheduleRepository.createTaskSchedule(
          schedule: taskSchedule,
        );
      }

      emit(state.copyWith(updateTaskStatus: UpdateTaskStatus.success));

      // Reload tasks to reflect changes
      add(const ParentTasks_Event_LoadTasks());
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          updateTaskStatus: UpdateTaskStatus.error,
          setUpdateTaskErrorMessage: e.toString,
        ),
      );
    }
  }

  Future<void> _onDeleteTask(
    ParentTasks_Event_DeleteTask event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(deleteTaskStatus: DeleteTaskStatus.deleting));
    try {
      // Delete the task template (and associated schedules if DB cascades)
      await _taskTemplateRepository.deleteTaskTemplate(id: event.id);

      emit(state.copyWith(deleteTaskStatus: DeleteTaskStatus.success));

      // reload tasks after deletion
      add(const ParentTasks_Event_LoadTasks());
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          deleteTaskStatus: DeleteTaskStatus.error,
          setDeleteTaskErrorMessage: e.toString,
        ),
      );
    }
  }

  Future<void> _onLoadTaskForEditing(
    ParentTasks_Event_LoadTaskForEditing event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(loadEditingDataStatus: LoadEditingDataStatus.loading));
    try {
      // Load the schedule to get the template ID
      final schedule = await _taskScheduleRepository.getTaskSchedule(
        id: event.scheduleId,
      );

      if (schedule == null) {
        emit(
          state.copyWith(
            loadEditingDataStatus: LoadEditingDataStatus.error,
            setLoadEditingDataErrorMessage: () => 'Schedule not found',
          ),
        );
        return;
      }

      // Load the template
      final template = await _taskTemplateRepository.getTaskTemplate(
        id: schedule.taskTemplateId,
      );

      // Load ALL schedules for this template
      final allSchedules = await _taskScheduleRepository.getTaskSchedules();
      final templateSchedules = allSchedules
          .where((s) => s.taskTemplateId == schedule.taskTemplateId)
          .toList();

      emit(
        state.copyWith(
          loadEditingDataStatus: LoadEditingDataStatus.loaded,
          setEditingSchedules: () => templateSchedules,
          setEditingTemplate: () => template,
        ),
      );
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          loadEditingDataStatus: LoadEditingDataStatus.error,
          setLoadEditingDataErrorMessage: e.toString,
        ),
      );
    }
  }
}
