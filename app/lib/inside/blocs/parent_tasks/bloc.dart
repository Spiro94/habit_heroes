import 'dart:async';

import 'package:bloc_concurrency/bloc_concurrency.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../outside/repositories/kid/repository.dart';
import '../../../outside/repositories/task_instances/repository.dart';
import '../../../outside/repositories/task_schedules/repository.dart';
import '../../../outside/repositories/task_templates/repository.dart';
import '../../../shared/models/task_schedule.dart';
import '../../../shared/models/task_template.dart';
import '../base.dart';
import 'events.dart';
import 'state.dart';

class ParentTasks_Bloc extends Bloc_Base<ParentTasks_Event, ParentTasks_State> {
  ParentTasks_Bloc({
    required Kid_Repository kidRepository,
    required TaskInstance_Repository taskInstanceRepository,
    required TaskTemplate_Repository taskTemplateRepository,
    required TaskSchedule_Repository taskScheduleRepository,
    required ParentTasks_State initialState,
  }) : _kidRepository = kidRepository,
       _taskInstanceRepository = taskInstanceRepository,
       _taskTemplateRepository = taskTemplateRepository,
       _taskScheduleRepository = taskScheduleRepository,
       super(initialState) {
    on<ParentTasks_Event_LoadTasks>(_onLoadTasks, transformer: sequential());
    on<ParentTasks_Event_AddTask>(_onAddTask, transformer: sequential());
    on<ParentTasks_Event_UpdateTask>(_onUpdateTask, transformer: sequential());
    on<ParentTasks_Event_DeleteTask>(_onDeleteTask, transformer: sequential());
  }

  final Kid_Repository _kidRepository;
  final TaskInstance_Repository _taskInstanceRepository;
  final TaskTemplate_Repository _taskTemplateRepository;
  final TaskSchedule_Repository _taskScheduleRepository;

  Future<void> _onLoadTasks(
    ParentTasks_Event_LoadTasks event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(status: ParentTasks_Status.loading));
    try {
      // Load today's task instances
      final taskInstances = await _taskInstanceRepository
          .getTodayTaskInstances();
      // RLS policies automatically filter kids by authenticated parent
      final kids = await _kidRepository.getKidsForParent();
      emit(
        state.copyWith(
          status: ParentTasks_Status.loaded,
          taskInstances: taskInstances,
          kids: kids,
        ),
      );
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          status: ParentTasks_Status.error,
          setErrorMessage: e.toString,
        ),
      );
    }
  }

  Future<void> _onAddTask(
    ParentTasks_Event_AddTask event,
    Emitter<ParentTasks_State> emit,
  ) async {
    emit(state.copyWith(status: ParentTasks_Status.loading));
    try {
      // Step 1: Create the task template
      final taskTemplate = TaskTemplate(
        id: '', // Will be generated by Supabase
        parentId: '', // Will be set by RLS policies
        title: event.title,
        description: event.description,
        points: event.points,
      );

      final createdTemplate = await _taskTemplateRepository.createTaskTemplate(
        template: taskTemplate,
      );

      // Step 2: Create MULTIPLE task schedules for the same template
      for (final scheduleInput in event.schedules) {
        final taskSchedule = TaskSchedule(
          id: '', // Will be generated by Supabase
          taskTemplateId: createdTemplate.id,
          kidId: scheduleInput.kidId,
          daysOfWeek: scheduleInput.daysOfWeek,
          timeOfDay: scheduleInput.timeOfDay != null
              ? _parseTimeOfDay(scheduleInput.timeOfDay!)
              : null,
          specificDate: scheduleInput.specificDate,
        );

        await _taskScheduleRepository.createTaskSchedule(
          schedule: taskSchedule,
        );
      }

      // Step 3: Reload tasks to show the new task instances
      add(const ParentTasks_Event_LoadTasks());
    } catch (e, stackTrace) {
      log.warning('${event.runtimeType}: error', e, stackTrace);
      emit(
        state.copyWith(
          status: ParentTasks_Status.error,
          setErrorMessage: e.toString,
        ),
      );
    }
  }

  TimeOfDay? _parseTimeOfDay(String timeOfDay) {
    switch (timeOfDay) {
      case 'morning':
        return TimeOfDay.morning;
      case 'afternoon':
        return TimeOfDay.afternoon;
      case 'evening':
        return TimeOfDay.evening;
      case 'night':
        return TimeOfDay.night;
      default:
        return null;
    }
  }

  Future<void> _onUpdateTask(
    ParentTasks_Event_UpdateTask event,
    Emitter<ParentTasks_State> emit,
  ) async {
    // TODO: Implement update task logic
  }

  Future<void> _onDeleteTask(
    ParentTasks_Event_DeleteTask event,
    Emitter<ParentTasks_State> emit,
  ) async {
    // TODO: Implement delete task logic
  }
}
